src.rag_toolkit.core.vectorstore
================================

.. py:module:: src.rag_toolkit.core.vectorstore

.. autoapi-nested-parse::

   Core vector store abstraction.

   This module defines the Protocol interface that all vector store implementations
   must satisfy, enabling seamless switching between different vector databases
   (Milvus, Pinecone, Qdrant, Weaviate, etc.) without changing application code.

   Design Philosophy:
       - Protocol-based: No inheritance required, duck typing with type safety
       - Provider-agnostic: Works with any vector database
       - Minimal interface: Only essential operations
       - Metadata support: Rich filtering and search capabilities



Classes
-------

.. autoapisummary::

   src.rag_toolkit.core.vectorstore.VectorStoreClient


Module Contents
---------------

.. py:class:: VectorStoreClient

   Bases: :py:obj:`Protocol`


   Protocol for vector store operations.

   This defines the interface that all vector store implementations must provide.
   It abstracts common operations across different vector databases.

   Implementations:
       - MilvusVectorStore: Milvus 2.x implementation
       - PineconeVectorStore: Pinecone cloud implementation (future)
       - QdrantVectorStore: Qdrant implementation (future)

   .. admonition:: Example

      >>> store: VectorStoreClient = MilvusVectorStore(host="localhost")
      >>> store.create_collection("docs", dimension=384)
      >>> ids = store.insert(
      ...     collection_name="docs",
      ...     vectors=[[0.1, 0.2, ...], ...],
      ...     texts=["doc 1", "doc 2"],
      ...     metadata=[{"source": "a"}, {"source": "b"}]
      ... )
      >>> results = store.search(
      ...     collection_name="docs",
      ...     query_vector=[0.1, 0.2, ...],
      ...     top_k=5
      ... )


   .. py:method:: create_collection(name, dimension, *, metric = 'IP', description = None, **kwargs)

      Create a new collection/index for storing vectors.

      :param name: Collection name (unique identifier)
      :param dimension: Vector dimension (e.g., 384, 768, 1536)
      :param metric: Distance metric ("IP"=inner product, "L2"=euclidean, "COSINE")
      :param description: Optional collection description
      :param \*\*kwargs: Provider-specific parameters

      :raises CollectionExistsError: If collection already exists
      :raises ValueError: If dimension <= 0 or invalid metric

      .. admonition:: Example

         >>> store.create_collection(
         ...     name="my_docs",
         ...     dimension=384,
         ...     metric="IP",
         ...     description="Product documentation embeddings"
         ... )



   .. py:method:: collection_exists(name)

      Check if a collection exists.

      :param name: Collection name

      :returns: True if collection exists, False otherwise



   .. py:method:: delete_collection(name)

      Delete a collection and all its data.

      :param name: Collection name

      :raises CollectionNotFoundError: If collection doesn't exist

      .. warning:: This operation is irreversible!



   .. py:method:: insert(collection_name, vectors, texts, metadata, *, ids = None, **kwargs)

      Insert vectors with associated text and metadata.

      :param collection_name: Target collection
      :param vectors: List of embedding vectors (must match collection dimension)
      :param texts: Source texts for each vector
      :param metadata: Metadata dict for each vector (for filtering)
      :param ids: Optional custom IDs (auto-generated if None)
      :param \*\*kwargs: Provider-specific parameters

      :returns: List of assigned IDs (in same order as input)

      :raises CollectionNotFoundError: If collection doesn't exist
      :raises ValueError: If vectors/texts/metadata lengths don't match
      :raises DimensionMismatchError: If vector dimension doesn't match collection

      .. admonition:: Example

         >>> ids = store.insert(
         ...     collection_name="docs",
         ...     vectors=[[0.1] * 384, [0.2] * 384],
         ...     texts=["First doc", "Second doc"],
         ...     metadata=[
         ...         {"source": "manual", "page": 1},
         ...         {"source": "api", "page": 5}
         ...     ]
         ... )
         >>> print(ids)  # ["id_001", "id_002"]



   .. py:method:: search(collection_name, query_vector, top_k = 10, *, filters = None, **kwargs)

      Search for similar vectors using ANN (approximate nearest neighbors).

      :param collection_name: Collection to search
      :param query_vector: Query embedding vector
      :param top_k: Number of results to return
      :param filters: Metadata filters (e.g., {"source": "manual"})
      :param \*\*kwargs: Provider-specific parameters (e.g., nprobe, ef)

      :returns: List of search results ordered by similarity (best first)

      :raises CollectionNotFoundError: If collection doesn't exist
      :raises DimensionMismatchError: If query dimension doesn't match collection

      .. admonition:: Example

         >>> results = store.search(
         ...     collection_name="docs",
         ...     query_vector=[0.15] * 384,
         ...     top_k=5,
         ...     filters={"source": "manual"}
         ... )
         >>> for result in results:
         ...     print(f"ID: {result.id}, Score: {result.score:.4f}")
         ...     print(f"Text: {result.text[:100]}...")



   .. py:method:: hybrid_search(collection_name, query_vector, query_text, top_k = 10, *, alpha = 0.5, filters = None, **kwargs)

      Hybrid search combining vector similarity and keyword matching.

      :param collection_name: Collection to search
      :param query_vector: Query embedding vector
      :param query_text: Query text for keyword search
      :param top_k: Number of results to return
      :param alpha: Weight for vector vs keyword (0=keyword only, 1=vector only)
      :param filters: Metadata filters
      :param \*\*kwargs: Provider-specific parameters

      :returns: List of search results with combined scores

      .. note::

         Not all vector stores support hybrid search natively.
         Default implementation may combine separate vector + keyword searches.

      .. admonition:: Example

         >>> results = store.hybrid_search(
         ...     collection_name="docs",
         ...     query_vector=[0.15] * 384,
         ...     query_text="installation guide",
         ...     top_k=5,
         ...     alpha=0.7  # Favor vector search
         ... )



   .. py:method:: delete(collection_name, ids)

      Delete vectors by IDs.

      :param collection_name: Collection name
      :param ids: List of vector IDs to delete

      :raises CollectionNotFoundError: If collection doesn't exist

      .. admonition:: Example

         >>> store.delete("docs", ids=["id_001", "id_003"])



   .. py:method:: get_stats(collection_name)

      Get collection statistics.

      :param collection_name: Collection name

      :returns:     - "count": Number of vectors
                    - "dimension": Vector dimension
                    - "metric": Distance metric
                    - Additional provider-specific stats
      :rtype: Dictionary with stats

      .. admonition:: Example

         >>> stats = store.get_stats("docs")
         >>> print(f"Collection has {stats['count']} vectors")



